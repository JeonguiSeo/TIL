SHOW USER;

-- 1. Table 확인
SELECT *
FROM TAB;

SELECT * FROM USER_TABLES; -- FROM USER_TABLES : Table 확인 가능

-- 2. Table 정보 확인 (DESC : Describe) -- Oracle Developer에서 사용 가능
DESC DEPT;
DESC EMP;

-- 3. 모든 Column 조회
SELECT *
FROM DEPT;

SELECT *
FROM EMP;

-- 4. Column 선택
SELECT DEPTNO, LOC
FROM DEPT;

-- 5. Column alias
SELECT DEPTNO AS 부서번호, LOC AS 위치
FROM DEPT; 

SELECT DEPTNO AS "부서 번호", LOC AS 위치 -- ""를 사용하여 alias의 공백 허용 가능 (alias 적용 시에만 사용)
FROM DEPT; 

-- 6. 연산 기능
SELECT EMPNO, SAL, SAL + 100 AS CALC
FROM EMP;

-- 7. 연결 기능 (||, 파이프 연산자)
SELECT EMPNO || ' ' || SAL AS "EMPNO AND SAL"
FROM EMP;

SELECT DEPTNO || ENAME || SAL
FROM EMP;

SELECT ENAME || '사원' -- 문자값 지정 시에는 '' 사용
FROM EMP;

-- 8. 중복값 제거 (DISTINCT)
SELECT DISTINCT JOB
FROM EMP;

-- 9. NULL 연산
SELECT EMPNO, SAL, COMM
FROM EMP;

SELECT ((SAL * 12) + COMM) AS ANNUAL_SAL -- Col 연산은 가능하나, 단순 row 연산 시 NULL로 처리
FROM EMP;

SELECT ((SAL * 12) + NVL(COMM, 0)) AS ANNUAL_SAL -- NVL(column, value if data is null)
FROM EMP;

-- 10. SELECTION 연산자
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL = 800;

SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE ENAME = 'FORD'; -- 조회 시에는 대소문자 구분 (MariaDB에서는 미구분)

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE HIREDATE = '80/12/17';

-- BETWEEN
SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE SAL BETWEEN 800 AND 2000;  -- A BETWEEN B : A와 B 포함

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE HIREDATE BETWEEN '80/01/10' AND '80/12/31';  -- A BETWEEN B : A와 B 포함

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE SAL IN (800, 1500, 2000); -- OR 조건으로 탐색

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE ENAME IN ('SMITH', 'FORD');

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE HIREDATE IN ('80/12/17', '80/12/01');

--  NULL 조회 (IS NULL)
SELECT EMPNO, ENAME, SAL, HIREDATE, COMM
FROM EMP
WHERE COMM IS NULL;

SELECT EMPNO, ENAME, SAL, HIREDATE, COMM
FROM EMP
WHERE COMM IS NOT NULL;

-- 유사값 조회 (LIKE + % or _)
SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE ENAME LIKE 'A%'; -- A로 시작하는 사원명 조회

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE ENAME LIKE '%T%'; -- T가 포함된 사원명 조회

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE ENAME LIKE '%S'; -- S로 끝나는 사원명 조회

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE ENAME LIKE '_L%'; -- 두 번째 글자가 L인 사원명 조회

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE ENAME LIKE '____N';

-- 논리 연산자 (AND, OR, NOT)
SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE JOB = 'SALESMAN' AND SAL >= 1500;

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE JOB = 'SALESMAN' OR SAL >= 1500;

SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE ENAME != 'FORD';

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE ENAME NOT IN ('SMITH', 'ALLEN');

-- 정렬 (ORDER BY)
SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
ORDER BY SAL; -- Default : ASC

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
ORDER BY SAL ASC;

SELECT EMPNO, ENAME, SAL, HIREDATE
FROM EMP
ORDER BY SAL DESC;

-- ORDER BY ALIAS
SELECT EMPNO, ENAME, SAL AS SALARY, HIREDATE
FROM EMP
ORDER BY SALARY ASC; -- ALIAS로 입력하지 않아도 조회 가능

-- ORDER BY 순서 지정
SELECT EMPNO, ENAME, SAL AS SALARY, HIREDATE
FROM EMP
ORDER BY 3;

-- Multiple ORDER BY
SELECT EMPNO, ENAME, SAL AS SALARY, HIREDATE
FROM EMP
ORDER BY SALARY, HIREDATE; -- SALARY로 정렬 후 HIREDATE 정렬 (ASC)

SELECT EMPNO, ENAME, SAL AS SALARY, HIREDATE
FROM EMP
ORDER BY SALARY, HIREDATE DESC;

SELECT EMPNO, ENAME, SAL AS SALARY, HIREDATE
FROM EMP
ORDER BY 3, 4 DESC; 

-- 함수
-- 1. 단일행 함수 - 문자 관련
-- 첫 글자를 대문자로 변경

SELECT INITCAP('ORACLE SERVER')
FROM DUAL;

SELECT DEPTNO, INITCAP(DNAME), INITCAP(LOC)
FROM DEPT;

-- 소문자 및 대문자로 변경
SELECT LOWER('MANAGER'), UPPER('manager') FROM DUAL;

SELECT EMPNO, ENAME, DEPTNO
FROM EMP
WHERE ENAME = 'SMITH';

-- 문자열 연결
SELECT CONCAT('ORACLE', 'SERVER'), 'ORACLE' || 'SERVER' FROM DUAL;

SELECT EMPNO, ENAME, JOB, CONCAT(ENAME, JOB)
FROM EMP;

-- 왼쪽 및 오른쪽 문자열 끼우기
-- 공백 채우기

SELECT LPAD('MILLER', 10), RPAD('MILLER', 10) FROM DUAL; -- 총 10개 문자가 되도록 문자를 채우는 기능 수행

-- * 채우기
SELECT LPAD('MILLER', 10, '*'), RPAD('MILLER', 10, '*') FROM DUAL; -- LPAD(문자, 총 글자 수 [, 채우기 문자])
SELECT ENAME, LPAD(ENAME, 15, '*') FROM EMP;

-- 부분열 변환
SELECT SUBSTR('000101-3234232', 8, 1) FROM DUAL; -- 8번째 문자부터 1개 문자를 추출
SELECT SUBSTR('000101-3234232', 8) FROM DUAL; -- 반환 문자 수 미지정 시, 8번째 문자부터 끝까지 추출

-- 문자열 길이 (수치값 반환)
SELECT LENGTH('000101-3234232') FROM DUAL;

-- 모든 함수값은 중첩 가능 -> function(function( ))
SELECT LENGTH(SUBSTR('000101-3234232', 8)) FROM DUAL;

-- 문자열 치환
SELECT REPLACE('JACK AND TUE', 'J', 'BL') FROM DUAL;
SELECT REPLACE('JACK AND TUE', 'J') FROM DUAL; -- 치환 문자열 미지정 시 공백으로 처리

-- 특정 문자의 위치 반환
SELECT INSTR('MILLER', 'L', 1) FROM DUAL; -- INSTR(문자열, 찾을 문자열 [, 시작 위치] [, N번째 결과]) 
SELECT INSTR('MILLER', 'L', 1, 2) FROM DUAL;
SELECT INSTR('MILLER', 'L', 5) FROM DUAL; -- 문자열을 찾지 못한 경우 0 반환

-- 왼쪽 및 오른쪽, 양쪽 공백(문자) 제거
SELECT LTRIM('MILLERM', 'M') FROM DUAL;
SELECT LTRIM('MMMMMILLERM', 'M') FROM DUAL; -- 지정 문자가 아닌 문자가 나타날 때까지 삭제 수행

SELECT RTRIM('MILLERM', 'M') FROM DUAL;
SELECT RTRIM('MILLERMMMMM', 'M') FROM DUAL;

-- 공백 문자 삭제
SELECT LTRIM('    MILLERM    ') FROM DUAL;
SELECT RTRIM('    MILLERM    ') FROM DUAL;

-- 왼쪽/오른쪽/양쪽 문자 OR 공백 제거
SELECT TRIM(LEADING 1 FROM 111234561111) FROM DUAL; 
SELECT TRIM(TRAILING 1 FROM 111234561111) FROM DUAL;
SELECT TRIM(BOTH 1 FROM 111234561111) FROM DUAL;

-- TEST - 보안 이슈로 주민번호 첫째 자리까지만 표시하고 나머지는 '*' 문자로 변경
SELECT '891202-1234567' FROM DUAL;

SELECT CONCAT(SUBSTR('891202-1234567', 1, 8), '******')  FROM DUAL;
SELECT SUBSTR('891202-1234567', 1, 8) || '******'  FROM DUAL;
SELECT RPAD(SUBSTR('891202-1234567', 1, 8), 14, '*')  FROM DUAL;

-- 2. 단일행 함수 - 수치형
SELECT CEIL(10.1) FROM DUAL;
SELECT FLOOR(10.1) FROM DUAL;

-- 나머지
SELECT MOD(10, 3) FROM DUAL; -- 10/3의 나머지값

-- 반올림
SELECT ROUND(456.789) FROM DUAL;
SELECT ROUND(456.789, 2) FROM DUAL;
SELECT ROUND(456.789 -1) FROM DUAL; -- 정수부는 음수로 지정
SELECT ROUND(456.789, -2) FROM DUAL;

-- 절삭
SELECT TRUNC(456.789) FROM DUAL;
SELECT TRUNC(456.789, 2) FROM DUAL;
SELECT TRUNC(456.789, -1) FROM DUAL;
SELECT TRUNC(456.789, -2) FROM DUAL;

-- 부호 식별
SELECT SIGN(100), SIGN(-10), SIGN(0) FROM DUAL;


-- 3. 단일행 함수 - 날짜
SELECT SYSDATE , SYSTIMESTAMP FROM DUAL;

-- Oracle에서는 날짜 연산 가능
SELECT SYSDATE, SYSDATE + 1, SYSDATE -1 FROM DUAL; -- DAY 연산
SELECT MONTHS_BETWEEN(SYSDATE+100, SYSDATE) FROM DUAL; -- MONTH 연산
SELECT TRUNC(MONTHS_BETWEEN(SYSDATE+100, SYSDATE)) FROM DUAL; -- 단순 개월 수 연산

-- MONTH 연산
SELECT ADD_MONTHS(SYSDATE, 1), ADD_MONTHS(SYSDATE, -1) FROM DUAL;

-- 요일 반환 (영문의 경우, 설치 버전의 인코딩이 한글이므로 사용 불가)
SELECT NEXT_DAY(SYSDATE, '화') FROM DUAL; -- 가장 가까운 화요일의 날짜를 반환
SELECT NEXT_DAY(SYSDATE, '수요일') FROM DUAL; 

-- 월의 마지막 날 반환
SELECT LAST_DAY(SYSDATE) FROM DUAL;

-- 날짜 반올림
SELECT SYSDATE, ROUND(SYSDATE, 'YEAR'), ROUND(SYSDATE, 'MONTH') FROM DUAL;

-- 날짜 절삭
SELECT TRUNC(SYSDATE, 'YEAR'), TRUNC(SYSDATE, 'MONTH') FROM DUAL;

-- 4. 단일행 함수 - 변환함수
-- 문자를 숫자로 변환
SELECT TO_NUMBER('100') + 100 FROM DUAL;

-- SELECT TO_NUMBER('1,000') + 100 FROM DUAL; -- 숫자에 comma가 있으면 인식 불가
SELECT TO_NUMBER('1,000', '9,999') + 100 FROM DUAL; -- Format 지정을 통해 인식 가능 (자릿수만큼 9 입력)
-- 단, format 지정 시 충분히 큰 자릿수로 9를 입력해야 출력 오류가 발생하지 않음

-- Locale 정보 지정
SELECT TO_CHAR(1000, 'L999,999') FROM DUAL; -- 현재 Locale 정보가 Korea이기 때문에 원화로 표시

SELECT TO_CHAR(1000, '$999,999') FROM DUAL;
SELECT TO_CHAR(100000000, 'L999,999,999,999') FROM DUAL;

-- 문자를 날짜로 변환
-- 3가지 날짜표현식 모두 Oracle에서 인식 가능
SELECT TO_DATE('2023/05/23') FROM DUAL;
SELECT TO_DATE('20230523') FROM DUAL;
SELECT TO_DATE('2023-05-23') FROM DUAL;
SELECT TO_DATE('2023, 05, 23') FROM DUAL;
SELECT TO_DATE('2023.05.23') FROM DUAL; -- Comma, period 모두 인식 가능

-- SELECT TO_DATE('2023년 05월 23일') FROM DUAL; -- 인식 불가능 형태

SELECT TO_DATE('2023, 05, 23', 'YYYY, MM, DD') FROM DUAL; -- format 지정 가능

SELECT TO_DATE('20230523124554') FROM DUAL;
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY/MM/dd HH:MI:SS'; -- 기본 일자 출력 형식 지정 가능 (임시적)
SELECT TO_DATE('20230523124554', 'YYYY/MM/dd HH:MI:SS') FROM DUAL; 

-- SELECT TO_DATE('2023년05월23일') FROM DUAL; -- 인식 불가한 형태로 format 지정 필요
SELECT TO_DATE('2023년05월23일', 'YYYY"년"MM"월"DD"일"') FROM DUAL; -- 동일 format 지정 필수
-- "년", "월", "일"을 구분하기 위해, ' ' 안에서 " " 추가 명시

-- 날짜를 문자로 변환
SELECT SYSDATE, TO_CHAR(SYSDATE) FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY') FROM DUAL; -- 특정 format만 추출
SELECT SYSDATE, TO_CHAR(SYSDATE, 'MM') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'HH') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'MI') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'SS') FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY:MM:DD') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY"년"MM"월"DD"일"') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY/MM/DD (AM)') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY/MM/DD (AM) DAY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY/MM/DD (AM) DY') FROM DUAL;
SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY/MM/DD (PM)') FROM DUAL;

SELECT SYSDATE, TO_CHAR(SYSDATE, 'YYYY/MM/DD (PM) HH24:MI:SS') FROM DUAL;

-- 날짜에서 특정 날짜 정보 얻기
SELECT SYSDATE,
			EXTRACT(YEAR FROM SYSDATE),
			EXTRACT(MONTH FROM SYSDATE),
			EXTRACT(DAY FROM SYSDATE),
			EXTRACT(HOUR FROM SYSDATE),
			EXTRACT(MINUTE FROM SYSDATE),
			EXTRACT(SECOND FROM SYSDATE)
FROM DUAL;


SELECT SYSDATE,
	   EXTRACT(YEAR FROM SYSDATE),
	   EXTRACT(MONTH FROM SYSDATE),
	   EXTRACT(DAY FROM SYSDATE),
	   EXTRACT(HOUR FROM SYSTIMESTAMP), -- 기본적으로 SYSDATE는 시, 분, 초를 포함하지 않으므로 SYSTIMESTAMP로 교체
	   EXTRACT(MINUTE FROM SYSTIMESTAMP),
	   EXTRACT(SECOND FROM SYSTIMESTAMP)
FROM DUAL;

-- 5. 단일행 함수 - CASE 함수
SELECT EMPNO, ENAME, SAL, JOB,
	CASE JOB WHEN 'ANALYIST' THEN SAL * 1.1
					WHEN 'CLERK' THEN SAL * 1.2
					WHEN 'MANAGER' THEN SAL * 1.3
					WHEN 'PRESIDENT' THEN SAL * 1.4
					WHEN 'SALESMAN' THEN SAL * 1.5
	END AS SALARY
FROM EMP;

SELECT EMPNO, JOB, SAL,
       CASE WHEN SAL >=0 AND SAL <=1000 THEN 'E' 
            WHEN SAL >1000 AND SAL <=2000 THEN 'D'
            WHEN SAL >2000 AND SAL <=3000 THEN 'C'
            WHEN SAL >3000 AND SAL <=4000 THEN 'B'
            WHEN SAL >4000 AND SAL <=5000 THEN 'A'
            ELSE 'N/A'
      END AS SALARY
FROM EMP;

-- TEST - 사원 테이블에서 입사일이 12월인 사원의 사번, 사원명, 입사일 검색
SELECT  EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE TO_CHAR(HIREDATE, 'MM') = '12';

SELECT  EMPNO, ENAME, SAL, HIREDATE
FROM EMP
WHERE EXTRACT(MONTH FROM HIREDATE) = '12';

-- TEST - 급여 결과 검색 (10자리 숫자, 빈 공간 '*')
SELECT  EMPNO, ENAME, LPAD(SAL, 10, '*')
FROM EMP;

-- TEST - 사번, 사원명, 입사일 검색 및 입사일 오름차순 정렬
SELECT EMPNO, ENAME, HIREDATE
FROM EMP
ORDER BY 3 ASC;


-- GROUP 함수
SELECT MAX(SAL), MIN(SAL), SUM(SAL), AVG(SAL), COUNT(*) -- SELECT ALL (*)은 COUNT에서만 사용 가능
FROM EMP;

-- 그룹화되지 않은 일반 column은 그룹함수화 함께 사용 불가

SELECT EMPNO, MAX(SAL)
FROM EMP
GROUP BY EMPNO;

-- 특정 coulmn COUNT 시, NULL값 제외 후 조회
-- 단, COUNT(*)는 전체 record를 조회
SELECT COUNT(COMM), COUNT(*) -- 특정 coulmn COUNT 시, NULL값 제외 후 조회
FROM EMP;

-- 부서별 최대 SAL 조회
SELECT DEPTNO, MAX(SAL)     
FROM EMP
GROUP BY DEPTNO;

-- 부서 & 직무별 최대 SAL 조회
SELECT DEPTNO, JOB, MAX(SAL)  
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY 1, 3;

-- Filtering
SELECT DEPTNO, MAX(SAL), COUNT(*)  
FROM EMP
GROUP BY DEPTNO;

SELECT DEPTNO, MAX(SAL),  COUNT(*) 
FROM EMP
WHERE SAL < 5000
GROUP BY DEPTNO;

SELECT DEPTNO, MAX(SAL), COUNT(*)
FROM EMP
WHERE SAL < 5000
GROUP BY DEPTNO
HAVING COUNT(*) > 2;

SELECT DEPTNO, MAX(SAL), COUNT(*)
FROM EMP
WHERE SAL < 5000
GROUP BY DEPTNO
HAVING COUNT(*) > 2
ORDER BY 2 DESC;

-- WHERE절에는 집계 함수 사용 불가

-- GROUP BY에서는 alias 및 순서 지정 사용 불가 (MSSQL에서는 사용 가능)
-- GROUP BY에서 사용할 column은 SELECT절에서 집계함수가 적용되어 있거나 상수값이어야 함

SELECT DEPTNO AS NO, MAX(SAL), COUNT(*), 'AAA'
FROM EMP
GROUP BY DEPTNO
HAVING COUNT(*) > 2
ORDER BY 2 DESC;

-- JOIN

-- 제약조건 확인
SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP';

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT';

-- 1) NATURAL JOIN : 공통 column 기반 교집합 생성
-- INNER JOIN : JOIN 시, 일치하는 데이터만 조회하는 방식 (불일치 시 누락)

SELECT *
FROM EMP NATURAL JOIN DEPT;

-- Filtering
SELECT * 
FROM EMP NATURAL JOIN DEPT
WHERE DEPTNO = 30;

SELECT DEPTNO, MAX(SAL)
FROM EMP NATURAL JOIN DEPT
GROUP BY DEPTNO
ORDER BY 1;

-- Table alias (AS 사용불가)
SELECT *
FROM EMP E NATURAL JOIN DEPT D; -- AS 사용 불가

-- Column 지정 시 테이블 정보 추가
-- 단, 공통 Column 지정 시 Table alias 사용 불가
SELECT EMPNO, ENAME, SAL, DNAME, LOC, DEPTNO
FROM EMP NATURAL JOIN DEPT;

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, DEPTNO --공통 Column인 DEPTNO에는 Alias 지정 불가
FROM EMP E NATURAL JOIN DEPT D;


-- 2) JOIN ~ USING(공통 Column) (INNER JOIN)
-- 공통 Column 지정 시 Table alias 사용 불가
SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, DEPTNO
FROM EMP E JOIN DEPT D USING(DEPTNO);

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, DEPTNO
FROM EMP E JOIN DEPT D USING(DEPTNO) -- JOIN 조건
WHERE DEPTNO = 30; -- Filter 조건

-- 3) JOIN ~ ON 조건식 (INNER JOIN)
-- 공통 column 지정 시, table name 필수 명시
SELECT EMPNO, ENAME, SAL, DNAME, LOC, DEPT.DEPTNO -- DEPTNO column은 중복되므로 테이블 명시 필수
FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO;

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, D.DEPTNO
FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO;

-- Filtering
SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, D.DEPTNO
FROM EMP E JOIN DEPT D ON E.DEPTNO = D.DEPTNO
WHERE D.DEPTNO = 10;

-- 동등 연산자를 통한 JOIN은 모두 Equi join
-- 부등 연산으로 JOIN 시 반드시 ON절 사용

SELECT *
FROM EMP JOIN SALGRADE ON SAL BETWEEN LOSAL AND HISAL;

SELECT EMPNO, ENAME, SAL, GRADE
FROM EMP JOIN SALGRADE ON SAL BETWEEN LOSAL AND HISAL;
 
SELECT E.EMPNO, E.ENAME, E.SAL, S.GRADE
FROM EMP E JOIN SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- 3개 테이블 JOIN
SELECT *
FROM EMP JOIN DEPT USING(DEPTNO)
				JOIN SALGRADE ON SAL BETWEEN LOSAL AND HISAL;

SELECT EMPNO, ENAME, DNAME, LOC, SAL, GRADE
FROM EMP JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO 
				JOIN SALGRADE ON SAL BETWEEN LOSAL AND HISAL;
			
-- SELF JOIN (일치하는 record만 출력)
SELECT E.ENAME AS 사원명, M.ENAME AS 관리자명
FROM EMP E JOIN EMP M ON E.MGR = M.EMPNO;
			
-- OUTER JOIN (일치하지 않는 record도 출력) (Developer에서 실행)
INSERT INTO EMP (EMPNO, ENAME, SAL, DEPTNO)
VALUES (9999, '홍길동', 500, NULL);
COMMIT;

SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, DEPTNO
FROM EMP E JOIN DEPT D USING(DEPTNO); -- EMP 에서는 9999 사원 누락,  DEPT 에서는 40 누락

-- EMP의 모든 record 출력
SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, DEPTNO
FROM EMP E LEFT OUTER JOIN DEPT D USING(DEPTNO);

-- DEPT의 모든 record 출력
SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, DEPTNO
FROM EMP E RIGHT OUTER JOIN DEPT D USING(DEPTNO);

-- EMP, DEPT의 모든 record 출력
SELECT E.EMPNO, E.ENAME, E.SAL, D.DNAME, D.LOC, DEPTNO
FROM EMP E FULL OUTER JOIN DEPT D USING(DEPTNO);


-- SUB QUERY
-- 1. 단일행 SUB QUERY
-- 1) WHERE 절 SUB QUERY
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL > (SELECT SAL
						FROM EMP
						WHERE ENAME = 'WARD');

-- 2) GRUOP 함수 이용
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP e WHERE SAL > (SELECT AVG(SAL)
										FROM EMP);
									
-- 2. 다중행 SUB QUERY
-- 업무별 최소급여를 받는 사원 조회
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL IN (SELECT MIN(SAL)
						FROM EMP
						GROUP BY JOB);

-- MANAGER 사원의 최소급여보다 적은 급여를 받는 사원 조회
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL < ALL (SELECT SAL
							FROM EMP
							WHERE JOB = 'MANAGER');

SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL < (SELECT MIN(SAL)
						FROM EMP
						WHERE JOB = 'MANAGER');
							
-- MANAGER 사원의 최대급여보다 많은 급여를 받는 사원 조회
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL > ALL (SELECT SAL
							FROM EMP
							WHERE JOB = 'MANAGER');
						
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL < (SELECT MAX(SAL)
						FROM EMP
						WHERE JOB = 'MANAGER');

-- MANAGER 사원의 최소급여보다 많은 급여를 받는 사원 조회
SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL > ANY (SELECT SAL
							FROM EMP
							WHERE JOB = 'MANAGER');

SELECT EMPNO, ENAME, JOB, SAL
FROM EMP
WHERE SAL > (SELECT MIN(SAL)
						FROM EMP
						WHERE JOB = 'MANAGER');

-- EXISTS					
-- 서브쿼리 결과값이 존재하는 경우
SELECT *
FROM EMP
WHERE EXISTS (SELECT EMPNO
               FROM EMP
               WHERE COMM IS NOT NULL);

SELECT *
FROM EMP
WHERE COMM IS NOT NULL;

              
-- 서브쿼리 결과값이 존재하지 않는 경우
SELECT *
FROM EMP
WHERE EXISTS (SELECT EMPNO
               			FROM EMP
               			WHERE ENAME IS NULL);

SELECT *
FROM EMP
WHERE ENAME IS NULL;


-- Oracle DML
-- 1. INSERT 
-- 1) 단일 생성 - 단일 record 생성
-- Column name 명시
SELECT * FROM DEPT;
INSERT INTO DEPT(DEPTNO, DNAME, LOC)
VALUES (50, '개발', '서울');

INSERT INTO DEPT(DEPTNO, DNAME)
VALUES (60, '개발');

COMMIT; -- 물리적인 파일에 반영

FROM TB_CLASS 

-- Column name 생략
INSERT INTO DEPT
VALUES (51, '개발', '서울');

SELECT * FROM DEPT;

COMMIT

--2) 다중 생성
-- CTAS (단, NOT NULL을 제외한 contstraint는 별도 지정 필요)
-- NOT NULL constraint만 자동 복사
-- CREATE는 DDL이므로, AUTO COMMIT
CREATE TABLE COPY_DEPT
AS
SELECT * FROM DEPT; 


CREATE TABLE COPY_DEPT2
AS
SELECT *
FROM DEPT
WHERE 1 = 2; -- HEADER 구조만 복사하여 사용하는 경우, WHERE 조건에 NULL 할당

-- INSERT를 활용하여 하나의 INSERT로 다중 record 생성 가능
INSERT INTO COPY_DEPT2
SELECT DEPTNO, DNAME, LOC
FROM DEPT;

-- 2. UPDATE
-- 1) 특정 record 수정 -- 일반적인 경우
SELECT * FROM DEPT;

UPDATE DEPT
SET DNAME = '인사', LOC = '제주'
WHERE DEPTNO = 50;

-- 2) 모든 record 수정
SELECT * FROM DEPT;

UPDATE DEPT
SET DNAME = '인사', LOC = '제주'; -- WHERE절 조건이 없으므로 모든 record 수정

ROLLBACK; -- ROLLBACK 시, COMMIT 이전 모든 DML은 취소

-- UPDATE + SUB QUERY
UPDATE DEPT SET DNAME = (SELECT DNAME FROM DEPT WHERE DEPTNO = 10),
							LOC = (SELECT DNAME FROM DEPT WHERE DEPTNO = 20)
WHERE DEPTNO = 50;

-- 3. DELETE 
-- 1) 특정 record 삭제
DELETE FROM DEPT
WHERE DEPTNO = 10; -- 타 테이블에서 FK로 참조하여, 제약조건 무결성에 위배

DELETE FROM DEPT
WHERE DEPTNO = 50;

SELECT * FROM DEPT;

--2) 모든 record 삭제
DELETE FROM EMP;

ROLLBACK;

-- DELETE + SUB QUERY

DELETE FROM DEPT
WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE DNAME = '개발');

SELECT * FROM DEPT
WHERE DNAME = '개발';

COMMIT;

-- DDL
-- 1. CREATE - 테이블 생성
-- Constraint 삭제로 무결성 보장 불가
CREATE TABLE DEPT_2 -- MariaDB에서는 CREATE TABLE IF NOT EXTSTS TABLE_NAME 사용 가능
(DEPTNO NUMBER(2), -- 0 ~ 99
DNAME VARCHAR2(10), -- 10 byte
LOC VARCHAR2(10));

SELECT * FROM DEPT_2;

-- 계정 내 테이블 정보 확인
SELECT *
FROM USER_TABLES; 

-- 2. Default
CREATE TABLE DEPT_3
(DEPTNO NUMBER(2),
DNAME VARCHAR2(10),
LOC VARCHAR2(10) DEFAULT '서울');  

INSERT INTO DEPT_3(DEPTNO, DNAME)
VALUES (1, '개발');

SELECT * FROM DEPT_3;


CREATE TABLE DEPT_3_1
(DEPTNO NUMBER(2),
DNAME VARCHAR2(10),
LOC VARCHAR2(10) DEFAULT '서울',
WRITEDAY DATE DEFAULT SYSDATE);

INSERT INTO DEPT_3_1 (DEPTNO, DNAME)
VALUES (1, '개발');

SELECT * FROM DEPT_3_1;

-- 3. Constraint
-- 1) Primary Key (Column level)
-- Constraint name 지정 방식 -- 관리를 위해 권장
CREATE TABLE TABLE1
( NO NUMBER(2) CONSTRAINT TABLE1_NO_PK PRIMARY KEY,
  EMAIL VARCHAR2(20));

INSERT INTO TABLE1 (NO, EMAIL) VALUES (1, 'AAA1');
INSERT INTO TABLE1 (NO, EMAIL) VALUES (2, 'AAA2'); -- UNIQUE constraint로 인해 2번 입력 불가
INSERT INTO TABLE1 (NO, EMAIL) VALUES (2, 'AAA2');
INSERT INTO TABLE1 (NO, EMAIL) VALUES (NULL, 'AAA3'); -- NOT NULL constraint로 인해 입력 불가

-- Constraint name 미지정 방식 -- 미지정 시 자동 지정 (e.g., SYS_0000)
CREATE TABLE TABLE1_1
( NO NUMBER(2) PRIMARY KEY,
EMAIL VARCHAR2(20));

-- Constraint 삭제 및 비활성화 가능
SELECT *
FROM USER_CONSTRAINTS;

-- Primary Key (Table level)
CREATE TABLE TABLE2
( NO NUMBER(2),
  EMAIL VARCHAR2(20),
  CONSTRAINT TABLE2_NO_PK PRIMARY KEY(NO)
 );

 SELECT *
 FROM USER_CONSTRAINTS;
 
-- Composite Identifier
CREATE TABLE TABLE2_1
( NO NUMBER(2),
  EMAIL VARCHAR2(20),
  ADDRESS VARCHAR2(20),
  CONSTRAINT TABLE2_1_NO_PK PRIMARY KEY(NO, EMAIL) -- Constraint name이 중복되지 않도록 주의
 );

-- 2) Unique
-- Unique (Column level)
-- Constraint name 지정 방식 -- 관리를 위해 권장
CREATE TABLE TABLE3
(NO NUMBER(2) CONSTRAINT TABLE3_NO_PK UNIQUE,
EMAIL VARCHAR2(20));

INSERT INTO TABLE3 (NO, EMAIL) VALUES (1, 'AAA');
INSERT INTO TABLE3 (NO, EMAIL) VALUES (2, 'AAA'); -- UNIQUE constraint로 인해 2번 입력 불가
INSERT INTO TABLE3 (NO, EMAIL) VALUES (NULL, 'AAA'); -- NULL은 중복 입력 가능

-- Unique (Table level)
CREATE TABLE TABLE4
(NO NUMBER(2),
  EMAIL VARCHAR2(20),
  CONSTRAINT TABLE4_NO_PK UNIQUE(NO)
 );
 
-- Composite Identifier - Pair로 비교
CREATE TABLE TABLE4_1
(NO NUMBER(2),
  EMAIL VARCHAR2(20),
  ADDRESS VARCHAR2(20),
  CONSTRAINT TABLE4_1_NO_PK PRIMARY KEY (NO, EMAIL) -- Constraint name이 중복되지 않도록 주의
 );

-- 3) NOT NULL (Column level)
CREATE TABLE TABLE7
(NO NUMBER(2) CONSTRAINT TABLE7_NO_NN NOT NULL,
  EMAIL VARCHAR2(20));
 
-- NOT NULL Table level은 지원하지 않음
 
 -- 4) CHECK (Column level)
CREATE TABLE TABLE5
( NO NUMBER(2) CONSTRAINT TABLE5_NO_CK CHECK(NO IN (10,20)),
  EMAIL VARCHAR(20));

INSERT INTO TABLE5 (NO, EMAIL) VALUES (10, 'AAA');
INSERT INTO TABLE5 (NO, EMAIL) VALUES (20, 'AAA'); 
INSERT INTO TABLE5 (NO, EMAIL) VALUES (30, 'AAA'); -- 규칙에 위배되므로 입력 불가
 
-- CHECK (Table level)
CREATE TABLE TABLE6
( NO NUMBER(2),
  EMAIL VARCHAR2(20),
  CONSTRAINT TABLE6_NO_CK CHECK(NO > 20)
  );
INSERT INTO TABLE6 (NO, EMAIL) VALUES (10, 'AAA'); -- 규칙에 위배되므로 입력 불가
INSERT INTO TABLE6 (NO, EMAIL) VALUES (20, 'AAA'); -- 규칙에 위배되므로 입력 불가
INSERT INTO TABLE6 (NO, EMAIL) VALUES (30, 'AAA'); 

-- 5) FOREIGN KEY
-- MASTER TABLE 생성
CREATE TABLE MASTER1
( NUM NUMBER(2) CONSTRAINT MASTER1_NUM_PK PRIMARY KEY,
  EMAIL VARCHAR2(10));

INSERT INTO MASTER1 (NUM, EMAIL) VALUES (1, 'AA1');
INSERT INTO MASTER1 (NUM, EMAIL) VALUES (2, 'AA2');
INSERT INTO MASTER1 (NUM, EMAIL) VALUES (3, 'AA3');
COMMIT; -- INSERT된 값을 파일에 저장하기 위해서는 COMMIT 필요

-- FOREIGN KEY (Column level)
CREATE TABLE SLAVE1
( NO NUMBER(2) CONSTRAINT SLAVE1_NO_PK PRIMARY KEY,
  NAME VARCHAR2(10),
  NUM NUMBER(2) CONSTRAINT SLAVE1_NUM_FK REFERENCES MASTER1(NUM) ON DELETE CASCADE);

INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (10, 'XXX1', 1);
INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (20, 'XXX2', 2);
INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (30, 'XXX3', 3);
-- INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (40, 'XXX4', 4); -- Master 테이블의 NUM에 4가 없으므로 에러 발생
INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (50, 'XXX5', NULL);

COMMIT;


-- Master 테이블의 NUM column 중에서 1을 가진 record 삭제
SELECT * FROM MASTER1;
SELECT * FROM SLAVE1;

DELETE FROM MASTER1
WHERE NUM = 1;

SELECT * FROM MASTER1;
SELECT * FROM SLAVE1; -- SLAVE1에서도 NUM = 1인 record가 삭제됨


-- FOREIGN KEY (Table level)
CREATE TABLE SLAVE2
( NO NUMBER(2) CONSTRAINT SLAVE2_NO_PK PRIMARY KEY,
  NAME VARCHAR2(10),
  NUM NUMBER(2),
  CONSTRAINT SLAVE2_NUM_FK FOREIGN KEY(NUM) REFERENCES MASTER1(NUM) ON DELETE SET NULL);
  
INSERT INTO SLAVE2 (NO, NAME, NUM) VALUES (20, 'XXX2', 2);
INSERT INTO SLAVE2 (NO, NAME, NUM) VALUES (30, 'XXX3', 3);
-- INSERT INTO SLAVE2 (NO, NAME, NUM) VALUES (40, 'XXX4', 4); -- Master 테이블의 NUM에 4가 없으므로 에러 발생
INSERT INTO SLAVE2 (NO, NAME, NUM) VALUES (50, 'XXX5', NULL);

COMMIT;

SELECT * FROM MASTER1;
SELECT * FROM SLAVE2;

DELETE FROM MASTER1
WHERE NUM = 2;

SELECT * FROM SLAVE2;

-- Master 테이블 삭제
SELECT * 
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'SLAVE2';

DROP TABLE MASTER1 CASCADE CONSTRAINTS;
-- Master1을 참조하고 있는 테이블들의 FK 제약조건을 삭제
-- Slave의 데이터는 유지
-- Oracle에서만 지원

SELECT * 
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'SLAVE2';

-- TEST  - 1. SUBJECT TABLE 생성
SELECT *
FROM NLS_DATABASE_PARAMETERS
WHERE PARAMETER = 'NLS_CHARACTERSET' OR PARAMETER = 'NLS NCHAR CHARACTERSET';
-- AL32UTF8은 한글을 3 byte로 처리

CREATE TABLE SUBJECT
(SUBNO NUMBER(5) CONSTRAINT SUBJECT_SUBNO_PK PRIMARY KEY,
SUBNAME VARCHAR2(20) CONSTRAINT SUBJECT_SUBNAME_NN NOT NULL,
TERM VARCHAR2(1) CONSTRAINT SUBJECT_TERM_CK CHECK(TERM IN (1, 2)),
TYPE VARCHAR2(6) CONSTRAINT SUBJECT_TYPE_CK CHECK(TYPE IN ('필수', '선택')));

INSERT INTO SUBJECT (SUBNO, SUBNAME, TERM, TYPE)
VALUES(1, 'AA', 1, '필수');


-- TEST - 2. SUGANG TABLE 생성 (STUDENT TABLE 인스턴스 참조)
CREATE TABLE STUDENT
(STUDNO NUMBER(5) CONSTRAINT STUDENT_STUDNO_PK PRIMARY KEY,
STUDAME VARCHAR2(10));

CREATE TABLE SUGANG
(STUDNO NUMBER(5), 
SUBNO NUMBER(5),
REGDATE DATE,
RESUT NUMBER(3),
CONSTRAINT SUGANG_STUDNO_PK PRIMARY KEY(STUDNO, SUBNO),
CONSTRAINT SUGANG_STUDNO_FK FOREIGN KEY(STUDNO) REFERENCES STUDENT(STUDNO), 
CONSTRAINT SUGANG_SUBNO_FK FOREIGN KEY(SUBNO) REFERENCES SUBJECT(SUBNO));


--
SELECT * FROM COPY_DEPT;
-- DML
DELETE FROM COPY_DEPT; -- DML은 record가 삭제된 테이블을 메모리에 임시 저장

ROLLBACK;

-- DDL
TRUNCATE TABLE COPY_DEPT;
SELECT * FROM COPY_DEPT;


-- 테이블 변경
CREATE TABLE MY_DEPT
AS
SELECT * FROM DEPT;

-- Column 추가
ALTER TABLE MY_DEPT
ADD(TEL VARCHAR(20));

ALTER TABLE MY_DEPT 
ADD(EMAIL VARCHAR(20), ADDR VARCHAR2(10));

-- Type 변경
ALTER TABLE MY_DEPT
MODIFY(TEL NUMBER(10));

SELECT *
FROM MY_DEPT
WHERE TABLE_NAME = 'MY_DEPT';

-- Column 삭제
ALTER TABLE MY_DEPT 
DROP(TEL);

ALTER TABLE MY_DEPT
DROP(EMAIL, ADDR);

-- 제약조건 추가 -- Table level 문법과 동일 (NOT NULL constraint는 ADD 추가 불가)
ALTER TABLE MY_DEPT
ADD CONSTRAINT MY_DEPT_DEOTNO_PK PRIMARY KEY(DEPTNO);

ALTER TABLE MY_DEPT 
ADD CONSTRAINT MY_DEPT_DNAME_UK UNIQUE(DNAME);

SELECT *
FROM ALL_TAB_COLUMNS
WHERE TABLE_NAME = 'MY_DEPT';

-- NOT NULL 제약조건 변경(추가)
ALTER TABLE MY_DEPT
MODIFY(LOC VARCHAR2(13) CONSTRAINTS MY_DEPT_LOC_NN NOT NULL);

-- 제약조건 삭제 (DROP PRIMARY KEY | DROP CONSTRAINT Constraint_name)
ALTER TABLE MY_DEPT
DROP PRIMARY KEY; -- PK는 테이블마다 1개씩만 존재하므로, 세부 이름을 지정하지 않아도 처리 가능

ALTER TABLE MY_DEPT
DROP CONSTRAINT MY_DEPT_DNAME_UK;

ALTER TABLE MY_DEPT
DROP CONSTRAINT MY_DEPT_LOC_NN;

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'MY_DEPT';

-- FK 참조가 존재하는 경우, MASTER의 PK 삭제

-- FK 조건 테이블 생성
CREATE TABLE MASTER1
( NUM NUMBER(2) CONSTRAINT MASTER1_NUM_PK PRIMARY KEY,
  EMAIL VARCHAR2(10));

INSERT INTO MASTER1 (NUM, EMAIL) VALUES (1, 'AA1');
INSERT INTO MASTER1 (NUM, EMAIL) VALUES (2, 'AA2');
INSERT INTO MASTER1 (NUM, EMAIL) VALUES (3, 'AA3');
COMMIT; 

DROP TABLE SLAVE1;

CREATE TABLE SLAVE1
( NO NUMBER(2) CONSTRAINT SLAVE1_NO_PK PRIMARY KEY,
  NAME VARCHAR2(10),
  NUM NUMBER(2) CONSTRAINT SLAVE1_NUM_FK REFERENCES MASTER1(NUM) ON DELETE CASCADE);

INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (10, 'XXX1', 1);
INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (20, 'XXX2', 2);
INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (30, 'XXX3', 3);
INSERT INTO SLAVE1 (NO, NAME, NUM) VALUES (50, 'XXX5', NULL);

COMMIT;
-----------------------------------------------------------------------------------

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'MASTER1'; -- PK 제약조건

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'SLAVE1'; -- PK / PK 제약조건

ALTER TABLE MASTER1
DROP PRIMARY KEY CASCADE; -- PK를 참조하는 모든 FK를 제거

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'MASTER1'; -- PK 삭제 확인 

SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'SLAVE1'; -- FK 삭제 확인

SELECT *
FROM SLAVE1;

SELECT *
FROM ALL_TAB_COLUMNS
WHERE TABLE_NAME = 'SLAVE1';


-- 테이블 삭제
-- DROP TABLE Table_name
DROP TABLE  MY_DEPT; 

-- VIEW 생성
-- SCOTT 계정은 기본 상태에서 CREATE VIEW 권한이 없음
-- 때문에 SYSTEM 계정에서 GRANT CREATE VIEW TO SCOTT; 쿼리 실행 필요
CREATE VIEW DEPT_VIEW
AS 
SELECT DEPTNO, DNAME
FROM DEPT;

SELECT *
FROM DEPT_VIEW;

SELECT *
FROM USER_VIEWS;